name: alert-promote
on:
  workflow_dispatch:

  issue_comment:
    types: [created, edited]

permissions:
  contents: write
  issues: write

jobs:
  promote:
    if: startsWith(github.event.issue.title, 'Alert YAML:') || contains(join(github.event.issue.labels.*.name, ','), 'alert-yaml')
    runs-on: ubuntu-latest
    steps:
      - id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = (context.payload.comment.body || '').trim();
            const lines = body.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
            const cmds = [];
            for (const ln of lines) {
              let m;
              if ((m = ln.match(/^(promote|demote)\s+(\S+)\s+(\S+)\s+(\d+(?:\.\d+)?)$/i))) {
                cmds.push({ op: m[1].toLowerCase(), ticker: m[2], rule: m[3], level: Number(m[4]) });
                continue;
              }
              if ((m = ln.match(/^promote-limit\s+(\d+)$/i))) {
                cmds.push({ op: 'limit', n: parseInt(m[1], 10) });
                continue;
              }
              if (/^demote-all$/i.test(ln)) { cmds.push({ op: 'demote_all' }); continue; }
              if (/^list$/i.test(ln))      { cmds.push({ op: 'list' });       continue; }
            }
            if (!cmds.length) core.setFailed('No valid command. Use `promote <ticker> <rule> <level>`, `demote ...`, `promote-limit <N>`, `demote-all`, or `list`.');
            core.setOutput('cmds', JSON.stringify(cmds));

      - id: load
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const path = 'config/alerts/promoted.json';
            let sha, data = { promoted: [], limit: 2 };
            try {
              const cur = await github.rest.repos.getContent({ owner, repo, path, ref: 'main' });
              if (!Array.isArray(cur.data)) {
                sha = cur.data.sha;
                data = JSON.parse(Buffer.from(cur.data.content, 'base64').toString('utf8'));
                if (!Array.isArray(data.promoted)) data.promoted = [];
                if (typeof data.limit !== 'number') data.limit = 2;
              }
            } catch (e) { if (e.status !== 404) throw e; }
            core.setOutput('path', path);
            core.setOutput('sha', sha || '');
            core.setOutput('json', JSON.stringify(data));

      - id: apply
        uses: actions/github-script@v7
        with:
          script: |
            const cmds = JSON.parse(`${{ steps.parse.outputs.cmds }}`);
            const state = JSON.parse(`${{ steps.load.outputs.json }}`);
            const list = state.promoted, limitDefault = state.limit ?? 2;

            const key = x => `${x.ticker}|${x.rule}|${x.level}`;
            const find = x => list.findIndex(y => key(y) === key(x));

            let changed = false, notes = [];

            for (const c of cmds) {
              if (c.op === 'list') { notes.push(`Current limit: ${state.limit}. Promoted: ${list.length ? list.map(key).join(', ') : '(none)'}`); continue; }
              if (c.op === 'limit') { state.limit = Math.max(0, c.n|0); changed = true; notes.push(`Set promote-limit=${state.limit}`); continue; }
              if (c.op === 'demote_all') { if (list.length) { list.length = 0; changed = true; } notes.push('Demoted ALL'); continue; }

              const item = { ticker: c.ticker, rule: c.rule, level: c.level };
              const idx = find(item);
              if (c.op === 'promote') {
                if (idx === -1) { list.push(item); changed = true; notes.push(`Promoted ${key(item)}`); }
                else { notes.push(`Already promoted: ${key(item)}`); }
              } else if (c.op === 'demote') {
                if (idx !== -1) { list.splice(idx, 1); changed = true; notes.push(`Demoted ${key(item)}`); }
                else { notes.push(`Not found: ${key(item)}`); }
              }
            }

            // Clamp to limit if necessary
            if (list.length > (state.limit ?? limitDefault)) {
              const removed = list.splice(state.limit);
              if (removed.length) { changed = true; notes.push(`Clamped to limit=${state.limit}; removed: ${removed.map(key).join(', ')}`); }
            }

            core.setOutput('changed', String(changed));
            core.setOutput('notes', notes.join('\n'));
            core.setOutput('newjson', JSON.stringify(state, null, 2));

      - id: save
        if: steps.apply.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const path = `${{ steps.load.outputs.path }}`;
            const sha  = `${{ steps.load.outputs.sha }}` || undefined;
            const content = Buffer.from(`${{ steps.apply.outputs.newjson }}`, 'utf8').toString('base64');
            const res = await github.rest.repos.createOrUpdateFileContents({
              owner, repo, path, content, sha, branch: 'main',
              message: `chore(alerts): update promotions from comment #${context.payload.comment.id}`
            });
            core.setOutput('url', res.data.content.html_url);

      - name: Comment back
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo, num = context.payload.issue.number;
            const notes = `${{ steps.apply.outputs.notes }}`;
            const url = `${{ steps.save.outputs.url || '' }}`;
            await github.rest.issues.createComment({
              owner, repo, issue_number: num,
              body: (context.payload.comment.body || '').trim() + '\n\n' + notes + (url ? `\n\nSaved: ${url}` : '')
            });
